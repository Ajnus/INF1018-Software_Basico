trabalho
UTF-8 vai de 8 a 32 bits
quando usando s√≥ 1 byte = ASCII

C√≥digo UNICODE                             | Representa√ß√£o UTF-8 (byte a byte)
U+0000 a U+007F    | (0 a 127[2^7 -1])     | 0xxxxxxx (1 a 7 bits bits)
U+0080 a U+07FF    | (128 a 2047[2^11 - 1])| 110xxxxx 10xxxxxx (8 a 11 bits)
U+0800 a U+FFFF	   | (2^11 a 2^16-1)  	   | 1110xxxx 10xxxxxx 10xxxxxx (12 a 16 bits)
U+10000 a U+10FFFF | (2^16 a 2^21-1)       | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (16 ~ 21)

BOM (u+FEFF): indica conte√∫do do arquivo como UNICODE. vem no in√≠cio do mesmo
distingue little de big endian, n√£o faz sentido para UTF-8 pois a mesma s√≥ usa 1 byte.(?) pois tem bits que n√£o representam valores(?)

|   Tipo do Arquivo     |     Bytes   |
| UTF-32, big-endian    | 00 00 FE FF | 
| UTF-32, little-endian	| FF FE 00 00 |

int utf8_32 (FILE *arq_entrada, FILE *arq_saida):
* LITTLE ENDIAN
* entrada:     sem BOM
* sa√≠da:       com BOM
* sucesso:     return 0; 
  falha:       erro de E/S: emitir, na sa√≠da de erro (stderr), uma mensagem indicando qual o tipo de 			  erro ocorrido (leitura ou grava√ß√£o) + return -1;
* assumir como entrada TEXTO CORRETAMENTE CODIFICADO

int utf32_8(FILE *arq_entrada, FILE *arq_saida):
* BOM  informa ENDIAN
* entrada:     com BOM
* sa√≠da:       sem BOM
* A fun√ß√£o deve inspecionar os primeiros quatro bytes do conte√∫do do arquivo de entrada (UTF-32) para verificar se eles cont√™m um BOM v√°lido!
* sucesso:     return 0;
* falha:	   1) erro de E/S: a fun√ß√£o deve emitir, na sa√≠da de erro (stderr), uma mensagem 						  indicando o tipo de erro ocorrido (leitura ou grava√ß√£o) + return -1;
			   2) BOM inv√°lido: a fun√ß√£o deve emitir, na sa√≠da de erro (stderr) uma mensagem de erro.	+ return -1;
			   * Nos dois casos, a fun√ß√£o deve retornar imediatamente ap√≥s emitir a mensagem de erro
* os arquivos de entrada sempre conter√£o um texto CORRETAMENTE CODIFICADO. Apenas o caso de BOM	   	   inv√°lido (ou ausente) no in√≠cio do arquivo precisa ser tratado. 


Divide and Conquer:
utf8_32:
	1) ler arquivo UTF-8
	2) mostrar na tela como UTF-32
	3) Funcionou? implemente nos valores
	4) gere arquivo de sa√≠da
	*  verificar o conte√∫do do arquivo gravado: hexdump -C <nome-do-arquivo>

***************** LITTLE ENDIAN ***************** 
		UTF-8					UTF-32
ESPA√áO  = 20			|		  20		
ùÑû		= F0 9D 84 9E	|	   1E D1 01 00	(0x1D11E)
Ê∞¥		= E6 B0 B4		|	   34 6C 00 00	(0x6C34)
.		= 2E			|		  2E
***************** LITTLE ENDIAN ***************** 

tamanho total:
<strike>UTF-8 tem 6 bytes a mais de informa√ß√£o que o tamanho total. Por qu√™?
UTF-32 tem 24 bytes a mais de informa√ß√£o que o tamanho total. Por qu√™?
(x4)</strike>
R: est√° em HEX, os valores batem.

Abrir arquivo:
FILE *fopen(char *path, char *mode);
mode: rb, wb
Ler:
fread/fgetc
Escrever:
fwrite/fputc

			UTF-8				UTF-32
ùÑû =       F0 9D 84 9E	 |	   1E D1 01 00	(0x1D11E)

int utf32_8(FILE *arq_entrada, FILE *arq_saida):
* VERIFICAR BOM (4 bytes) // CHECKED
	1) erro de E/S: a fun√ß√£o deve emitir, na sa√≠da de erro (stderr), uma mensagem 	   indicando o tipo de erro ocorrido (leitura ou grava√ß√£o) + return -1;
	2) BOM inv√°lido: a fun√ß√£o deve emitir, na sa√≠da de erro (stderr) uma mensagem 	   de erro.	+ return -1; 			// CHECKED
	3) else: segue


          0x0001D11E    ->      0xF09D849E ("a ordem de armazenamento n√£o faz sentido 					                   para arquivos UTF-8")
 0    0    0    1    D    1    1    E
0000 0000 0000 0001 1101 0001 0001 1110 
0001D11E-> tabela -> U+10000 a U+10FFFF | (2^16 a 2^21-1)| 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (usa 4 bytes)
0001D11E -> 11110|3BITS 10|6BITS 10|6BITS 10|6BITS -> 
			calcular e preencher primeiro 0's a esquerda: n m√°ximo de bits da se√ß√£o da tabela - n√∫mero de bits significativos do n√∫mero-> (21 - 17 = 4)
            11110|000   10011101 10000100 10011110 -> 
            1111 0000 1001 1101 1000 0100 1001 1110
              F    0    9   D    8    4    9    E  -> GG
